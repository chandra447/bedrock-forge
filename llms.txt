# Bedrock Forge

Bedrock Forge is an enterprise platform that transforms YAML configurations into AWS Bedrock agent deployments using Terraform modules. It eliminates repetitive Terraform code by providing a YAML-driven configuration approach for AWS Bedrock services.

## Features

**Core Capabilities:**
- **YAML to Terraform Conversion**: Transform declarative YAML configurations into production-ready Terraform modules
- **Multi-Resource Support**: Agents, Lambda functions, Action Groups, Knowledge Bases, Guardrails, Prompts, IAM roles, and Custom Modules
- **Custom Module Integration**: Include your own Terraform modules alongside Bedrock resources
- **Automatic IAM Role Generation**: Generate comprehensive IAM roles with foundation model, Lambda, and knowledge base permissions
- **Dependency Management**: Automatic resolution and ordering of resource dependencies
- **Artifact Packaging**: Automated Lambda code packaging and OpenAPI schema management
- **Enterprise Governance**: Enforce naming conventions, tagging policies, and security standards
- **CI/CD Integration**: GitHub Actions workflows for automated deployment pipelines

## Technology Stack
- **Go CLI Tool** (cobra-based) for YAML processing and Terraform generation
- **HashiCorp HCL/Terraform** for infrastructure-as-code generation
- **AWS Bedrock** for agent, guardrail, knowledge base, and prompt management
- **GitHub Actions** for CI/CD automation
- **S3** for artifact storage (Lambda code, OpenAPI schemas)

## Supported Resources

**AWS Bedrock Resources:**
- **Agent**: Bedrock conversational agents with foundation models, instructions, inline action groups, and deployment aliases
- **Lambda**: AWS Lambda functions for action groups with runtime and environment settings
- **ActionGroup**: Agent action capabilities with API schemas and executors (requires agent association)
- **KnowledgeBase**: Vector knowledge bases with embeddings and data sources
- **OpenSearchServerless**: Auto-created OpenSearch Serverless collections with security policies for knowledge bases
- **Guardrail**: Content safety and compliance with filters and policies
- **Prompt**: Custom prompt templates with TEXT/CHAT types, input variables, tool calling, and encryption support
- **IAMRole**: IAM execution roles with policies and permissions

**Infrastructure Integration:**
- **CustomModule**: Include any Terraform module (local, registry, or git) alongside Bedrock resources
- **AgentKnowledgeBaseAssociation**: Link agents to knowledge bases for retrieval capabilities

## YAML Configuration Examples

### Agent Configuration
```yaml
kind: Agent
metadata:
  name: "customer-support"
  description: "Customer support agent"
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are a helpful customer support agent..."
  idleSessionTtlInSeconds: 3600
  guardrail:
    name: "content-safety-guardrail"
    version: "1"
    mode: "pre"
  # Inline action groups (new structure)
  actionGroups:
    - name: "order-lookup"
      description: "Look up customer orders"
      actionGroupExecutor:
        lambda: "order-lookup-lambda"
      functionSchema:
        functions:
          - name: "lookup_order"
            parameters:
              order_id:
                type: "string"
                required: true
  # IAM role is automatically generated!
  promptOverrides:
    - promptType: "ORCHESTRATION"
      prompt: "custom-orchestration-prompt"
      variant: "production"
  memoryConfiguration:
    enabledMemoryTypes: ["SESSION_SUMMARY"]
    storageDays: 30
  
  # Agent aliases for deployment strategies
  aliases:
    - name: "dev"
      description: "Development version for testing"
      tags:
        Environment: "dev"
        Purpose: "development"
    
    - name: "prod"
      description: "Production version"
      tags:
        Environment: "prod"
        Purpose: "production"
        CriticalService: "true"
```

### Agent Aliases

Agent aliases enable deployment strategies like staging, production, and environment separation by creating named references to agent deployments.

#### Basic Alias Configuration
```yaml
aliases:
  - name: "dev"
    description: "Development version for testing"
    tags:
      Environment: "dev"
      Purpose: "development"
  
  - name: "prod"
    description: "Production version"
    tags:
      Environment: "prod"
      Purpose: "production"
```

#### Multiple Environment Aliases
```yaml
aliases:
  - name: "dev"
    description: "Development environment"
    tags:
      Environment: "dev"
      Purpose: "development"
      AutoUpdate: "true"
  
  - name: "staging"
    description: "Staging environment for testing"
    tags:
      Environment: "staging"
      Purpose: "pre-production"
      ApprovalRequired: "true"
  
  - name: "prod"
    description: "Production environment"
    tags:
      Environment: "prod"
      Purpose: "production"
      CriticalService: "true"
```

#### Deployment Benefits
- **Environment Separation**: Dev, staging, and production aliases
- **Named References**: Stable references to agents across environments
- **Environment-Specific Tagging**: Tag aliases for different deployment contexts
- **Simplified Management**: Organize agent deployments by purpose and environment
- **CI/CD Integration**: Use aliases in deployment pipelines for different stages

### Lambda Configuration

**Basic Lambda Function:**
```yaml
kind: Lambda
metadata:
  name: "order-lookup"
  description: "Lambda function to look up orders"
spec:
  runtime: "python3.9"
  handler: "app.handler"
  code:
    source: "directory"  # Code co-located with YAML
  environment:
    ORDER_API_URL: "https://api.company.com/orders"
    LOG_LEVEL: "INFO"
  timeout: 30
  memorySize: 256
```

**Zero-Configuration Lambda Functions:**
```yaml
kind: Lambda
metadata:
  name: "order-lookup"
  description: "Lambda function to look up customer orders"
spec:
  runtime: "python3.9"
  handler: "app.handler"
  code:
    source: "directory"
  environment:
    ORDER_API_URL: "https://api.company.com/orders"
  timeout: 30
  memorySize: 256
# No resource policy needed - bedrock-forge handles permissions automatically!
```

**Automatic Permission Management:**
- **Zero Configuration Required**: No manual policy setup needed for Lambda functions
- **Intelligent Detection**: Lambda generator automatically scans all agents to detect which ones reference each Lambda function
- **Agent-Specific Permissions**: When agents reference a Lambda, automatic creation of agent-specific permissions with `aws:SourceArn` restrictions
- **Future-Proof Permissions**: Lambda functions not yet referenced by agents get general Bedrock permissions for future use
- **Maximum Security**: Each agent can only invoke Lambda functions it specifically references in action groups
- **Enterprise Flexibility**: Optional custom `resourcePolicy` configuration for advanced scenarios

**Permission Logic:**
- **With Agent References**: Creates agent-specific permissions using `${module.agent_name.agent_arn}` as source ARN condition
- **Without Agent References**: Creates general `bedrock.amazonaws.com` permission ready for future agent integration
- **Custom Policies**: Advanced users can add additional policy statements for cross-account access or enterprise requirements

### ActionGroup Configuration

**Using Local Lambda Resource:**
```yaml
kind: ActionGroup
metadata:
  name: "order-management"
  description: "Action group for order operations"
spec:
  # Required: Agent ID (module reference or direct ARN)
  agentId: "${module.customer_support.agent_id}"  # References local agent module
  agentVersion: "DRAFT"                            # Optional: Agent version (defaults to DRAFT)
  description: "Provides order lookup capabilities"
  # Required: Action group executor
  actionGroupExecutor:
    lambda: "order-lookup"  # References Lambda resource defined in same project
  apiSchema:
    s3:
      s3BucketName: "bedrock-schemas"
      s3ObjectKey: "action-groups/order-management/openapi.json"
  # Function schema for simple cases
  functionSchema:
    functions:
      - name: "lookup_order"
        description: "Look up order details by order ID"
        parameters:
          order_id:
            type: "string"
            description: "The unique order identifier"
            required: true
```

**Using Existing Lambda ARN (Shared Lambda):**
```yaml
kind: ActionGroup
metadata:
  name: "shared-inventory-management"
  description: "Action group using shared Lambda function"
spec:
  # Required: Agent ID (direct ARN for existing agent)
  agentId: "arn:aws:bedrock:us-east-1:123456789012:agent/ABCD1234"  # Existing agent ARN
  agentVersion: "1"  # Use specific version for production
  description: "Provides inventory management using shared team Lambda function"
  # Required: Action group executor
  actionGroupExecutor:
    lambdaArn: "arn:aws:lambda:us-east-1:123456789012:function:inventory-team-prod-inventory-service"
  apiSchema:
    s3:
      s3BucketName: "bedrock-schemas"
      s3ObjectKey: "action-groups/shared-inventory-management/openapi.json"
  tags:
    Environment: "prod"
    Project: "inventory-management"
    Owner: "inventory-team@company.com"
```

**Important**: When using `lambdaArn`, ensure the Bedrock agent's IAM role has `lambda:InvokeFunction` permission for the specified Lambda function.

### KnowledgeBase Configuration

**Enhanced with OpenSearch Serverless Auto-Creation (Recommended):**

```yaml
# 1. Auto-create OpenSearch Serverless collection with all required policies
kind: OpenSearchServerless
metadata:
  name: "customer-kb-collection"
spec:
  collectionName: "customer-knowledge-base"
  type: "VECTORSEARCH"
  accessPolicy:
    autoConfigureForBedrock: true  # Automatically adds Bedrock permissions
  vectorIndex:
    name: "customer-kb-index"
    fieldMapping:
      vectorField: "vector"
      textField: "text"
      metadataField: "metadata"

---
# 2. Reference the auto-created collection
kind: KnowledgeBase
metadata:
  name: "faq-kb"
  description: "Customer FAQ knowledge base with auto-managed storage"
spec:
  knowledgeBaseConfiguration:
    type: "VECTOR"
    vectorKnowledgeBaseConfiguration:
      embeddingModelArn: "arn:aws:bedrock:us-east-1::foundation-model/amazon.titan-embed-text-v1"
  storageConfiguration:
    type: "OPENSEARCH_SERVERLESS"
    openSearchServerless:                    # Enhanced configuration
      collectionName: "customer-kb-collection"  # References auto-created collection
      vectorIndexName: "customer-kb-index"
      fieldMapping:
        vectorField: "vector"
        textField: "text"
        metadataField: "metadata"
  dataSources:
    - name: "faq-documents"
      type: "S3"
      s3Configuration:
        bucketArn: "arn:aws:s3:::company-kb-documents"
        inclusionPrefixes: ["faq/"]
      chunkingConfiguration:
        chunkingStrategy: "FIXED_SIZE"
        fixedSizeChunkingConfiguration:
          maxTokens: 512
          overlapPercentage: 20
```

**Using Existing OpenSearch Serverless Collection:**

```yaml
kind: KnowledgeBase
metadata:
  name: "existing-collection-kb"
spec:
  storageConfiguration:
    type: "OPENSEARCH_SERVERLESS"
    openSearchServerless:
      collectionArn: "arn:aws:aoss:us-east-1:123456789012:collection/existing-kb"
      vectorIndexName: "existing-index"
      fieldMapping:
        vectorField: "embedding_vector"
        textField: "document_content" 
        metadataField: "doc_metadata"
```

**Legacy Configuration (Still Supported):**

```yaml
storageConfiguration:
  type: "OPENSEARCH_SERVERLESS"
  opensearchServerlessConfiguration:  # Legacy format
    collectionArn: "arn:aws:aoss:us-east-1:123456789012:collection/bedrock-kb"
    vectorIndexName: "bedrock-knowledge-base-index"
    fieldMapping:
      vectorField: "vector"
      textField: "text"
      metadataField: "metadata"
```

### Guardrail Configuration
```yaml
kind: Guardrail
metadata:
  name: "content-safety-guardrail"
  description: "Enterprise content safety guardrail"
spec:
  contentPolicyConfig:
    filtersConfig:
      - type: "SEXUAL"
        inputStrength: "HIGH"
        outputStrength: "HIGH"
      - type: "VIOLENCE"
        inputStrength: "MEDIUM"
        outputStrength: "HIGH"
  sensitiveInformationPolicyConfig:
    piiEntitiesConfig:
      - type: "EMAIL"
        action: "BLOCK"
      - type: "PHONE"
        action: "ANONYMIZE"
```

### Prompt Configuration

**TEXT Template with Input Variables:**
```yaml
kind: Prompt
metadata:
  name: "customer-support-prompt"
  description: "Customer support prompt with input variables"
spec:
  defaultVariant: "production"
  
  # Define input variables that can be used in templates
  inputVariables:
    - name: "query"
    - name: "context"
    - name: "customer_name"
  
  # Optional: Customer encryption key for sensitive prompts
  customerEncryptionKeyArn: "arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012"
  
  variants:
    - name: "production"
      modelId: "anthropic.claude-3-sonnet-20240229-v1:0"
      templateType: "TEXT"
      templateConfiguration:
        text:
          text: |
            You are a professional customer support agent.
            
            Customer: {{customer_name}}
            Query: {{query}}
            Context: {{context}}
            
            Please provide a helpful response.
          
          # Define which variables this template uses
          inputVariables:
            - name: "query"
            - name: "context"
            - name: "customer_name"
      
      inferenceConfiguration:
        text:
          temperature: 0.1
          topP: 0.9
          topK: 50
          maxTokens: 2048
          stopSequences: ["Human:", "Assistant:"]
```

**CHAT Template with Tool Calling:**
```yaml
kind: Prompt
metadata:
  name: "ai-assistant-chat"
  description: "Chat-based AI assistant with tool calling"
spec:
  defaultVariant: "production"
  
  inputVariables:
    - name: "user_query"
    - name: "user_name"
  
  variants:
    - name: "production"
      modelId: "anthropic.claude-3-sonnet-20240229-v1:0"
      templateType: "CHAT"
      templateConfiguration:
        chat:
          # System messages provide instructions
          system:
            - text: "You are a helpful AI assistant with access to tools."
          
          # Conversation messages (can include variables)
          messages:
            - role: "user"
              content:
                - text: "Hello, I'm {{user_name}}. {{user_query}}"
          
          # Tool configuration for function calling
          toolConfiguration:
            tools:
              - toolSpec:
                  name: "search_knowledge_base"
                  description: "Search knowledge base for information"
                  inputSchema:
                    json:
                      type: "object"
                      properties:
                        query:
                          type: "string"
                          description: "Search query"
                        category:
                          type: "string"
                          enum: ["products", "policies", "faq"]
                      required: ["query"]
              
              - toolSpec:
                  name: "get_order_status"
                  description: "Get customer order status"
                  inputSchema:
                    json:
                      type: "object"
                      properties:
                        order_id:
                          type: "string"
                          description: "Order ID to look up"
                      required: ["order_id"]
            
            # Tool choice configuration
            toolChoice:
              auto: {}  # Let the model decide when to use tools
              # any: {}   # Model must use at least one tool
              # tool:     # Force specific tool
              #   name: "search_knowledge_base"
          
          inputVariables:
            - name: "user_query"
            - name: "user_name"
      
      inferenceConfiguration:
        text:
          temperature: 0.2
          topP: 0.9
          maxTokens: 4096
```

### Custom Module Configuration

Include your own Terraform modules alongside Bedrock resources:

```yaml
kind: CustomModule
metadata:
  name: "s3-storage"
  description: "S3 bucket for artifacts"
spec:
  # Local module
  source: "./modules/s3-bucket"
  
  # Or Terraform registry module
  # source: "terraform-aws-modules/s3-bucket/aws"
  # version: "3.0.0"
  
  # Or git repository module
  # source: "git::https://github.com/org/repo.git"
  # version: "v1.2.0"
  
  variables:
    bucket_name: "bedrock-artifacts-${var.environment}"
    versioning_enabled: true
    # Support all variable types: strings, numbers, booleans, lists, objects
    lifecycle_rules:
      - id: "delete_old_versions"
        enabled: true
        noncurrent_version_expiration_days: 30
  
  # Optional dependencies
  dependsOn:
    - "vpc-module"
    - "customer-support"  # Wait for agent creation
  
  tags:
    Purpose: "BedrockStorage"
    Environment: "${var.environment}"
```

### IAMRole Configuration (Optional)

**Note: IAM roles are now automatically generated for all agents. Manual configuration is optional.**
```yaml
kind: IAMRole
metadata:
  name: "custom-agent-execution-role"
  description: "Custom IAM role for Bedrock agent"
spec:
  assumeRolePolicy:
    version: "2012-10-17"
    statement:
      - effect: "Allow"
        principal:
          service: "bedrock.amazonaws.com"
        action: "sts:AssumeRole"
  policies:
    - policyArn: "arn:aws:iam::aws:policy/service-role/AmazonBedrockAgentResourcePolicy"
  inlinePolicies:
    - name: "BedrockFoundationModelAccess"
      policy:
        version: "2012-10-17"
        statement:
          - effect: "Allow"
            action:
              - "bedrock:InvokeModel"
              - "bedrock:InvokeModelWithResponseStream"
            resource: "arn:aws:bedrock:*::foundation-model/*"
```

### Agent-Knowledge Base Association

Link agents to knowledge bases (separate from agent definition):

```yaml
kind: AgentKnowledgeBaseAssociation
metadata:
  name: "agent-faq-link"
  description: "Link customer support agent to FAQ knowledge base"
spec:
  agentName: "customer-support"     # Reference agent by name
  knowledgeBaseName: "faq-kb"       # Reference knowledge base by name
  # agentId: "ABCD1234"              # Or use direct IDs
  # knowledgeBaseId: "EFGH5678"
  description: "FAQ knowledge base for customer support"
  state: "ENABLED"
```

## CLI Usage

**Core Commands:**
```bash
# Discover and scan resources in directory
bedrock-forge scan [path]

# Validate YAML syntax and dependencies
bedrock-forge validate [path] [--profile enterprise|custom] [--config path/to/config.yml]

# Generate Terraform modules from YAML
bedrock-forge generate [path] [output-dir]

# Show version information
bedrock-forge version
```

**Validation Modes:**
- **Default**: Development-friendly validation with basic checks
- **Enterprise**: Production-ready validation with strict governance policies
- **Custom**: User-defined validation rules via configuration file

## Getting Started Guide

### Prerequisites

Before starting, ensure you have:
- **Go 1.21+** installed
- **AWS CLI** configured with appropriate credentials
- **Terraform 1.0+** installed
- **Git repository** for your project
- **AWS account** with Bedrock access enabled

### Installation

**Option 1: Global Installation (Recommended)**
```bash
go install github.com/your-org/bedrock-forge/cmd/bedrock-forge@latest
bedrock-forge version
```

**Option 2: Clone and Build**
```bash
git clone https://github.com/your-org/bedrock-forge
cd bedrock-forge
go build -o bedrock-forge ./cmd/bedrock-forge
./bedrock-forge version
```

### Quick Start: Create Your First Agent

**Step 1: Create Project Directory**
```bash
mkdir my-bedrock-project
cd my-bedrock-project
```

**Step 2: Create Simple Agent**
```bash
# Create agent.yml
cat > agent.yml << 'EOF'
kind: Agent
metadata:
  name: "hello-agent"
  description: "My first Bedrock agent"
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are a helpful AI assistant that provides clear and concise answers."
  idleSessionTtlInSeconds: 3600
  
  tags:
    Environment: "dev"
    Project: "my-first-agent"
    Owner: "developer@company.com"
EOF
```

**Step 3: Generate and Deploy**
```bash
# Validate configuration
bedrock-forge validate .

# Generate Terraform
bedrock-forge generate . ./terraform

# Deploy with Terraform
cd terraform
terraform init
terraform plan
terraform apply
```

### Adding Lambda Functions

**Step 1: Create Lambda Function**
```bash
# Create lambda.yml
cat > lambda.yml << 'EOF'
kind: Lambda
metadata:
  name: "weather-lookup"
  description: "Get weather information"
spec:
  runtime: "python3.11"
  handler: "app.handler"
  code:
    source: "directory"  # Code in same directory
  environment:
    API_KEY: "your-weather-api-key"
  timeout: 30
  memorySize: 256
  
  tags:
    Environment: "dev"
    Project: "weather-service"
EOF
```

**Step 2: Create Lambda Code**
```bash
# Create app.py
cat > app.py << 'EOF'
import json
import os

def handler(event, context):
    # Extract function name and parameters
    function_name = event.get('function', '')
    parameters = event.get('parameters', {})
    
    if function_name == 'get_weather':
        location = parameters.get('location', 'Unknown')
        # Mock weather data - replace with real API call
        weather_data = {
            'location': location,
            'temperature': '22°C',
            'condition': 'Sunny',
            'humidity': '45%'
        }
        return {
            'statusCode': 200,
            'body': json.dumps(weather_data)
        }
    
    return {
        'statusCode': 400,
        'body': json.dumps({'error': 'Unknown function'})
    }
EOF
```

**Step 3: Update Agent with Action Group**
```bash
# Update agent.yml
cat > agent.yml << 'EOF'
kind: Agent
metadata:
  name: "weather-agent"
  description: "Agent with weather lookup capability"
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are a helpful weather assistant. Use the get_weather function to provide current weather information for any location."
  idleSessionTtlInSeconds: 3600
  
  # Inline action groups
  actionGroups:
    - name: "weather-tools"
      description: "Weather lookup tools"
      actionGroupExecutor:
        lambda: "weather-lookup"  # References Lambda above
      functionSchema:
        functions:
          - name: "get_weather"
            description: "Get current weather for a location"
            parameters:
              location:
                type: "string"
                description: "City name or location"
                required: true
  
  tags:
    Environment: "dev"
    Project: "weather-agent"
    Owner: "developer@company.com"
EOF
```

### Adding Knowledge Base

**Step 1: Create Knowledge Base**
```bash
# Create knowledge-base.yml
cat > knowledge-base.yml << 'EOF'
kind: KnowledgeBase
metadata:
  name: "company-faq"
  description: "Company FAQ knowledge base"
spec:
  knowledgeBaseConfiguration:
    type: "VECTOR"
    vectorKnowledgeBaseConfiguration:
      embeddingModelArn: "arn:aws:bedrock:us-east-1::foundation-model/amazon.titan-embed-text-v1"
  
  storageConfiguration:
    type: "OPENSEARCH_SERVERLESS"
    openSearchServerless:
      collectionArn: "arn:aws:aoss:us-east-1:123456789012:collection/kb-collection"
      vectorIndexName: "knowledge-index"
      fieldMapping:
        vectorField: "vector"
        textField: "text"
        metadataField: "metadata"
  
  dataSources:
    - name: "faq-documents"
      type: "S3"
      s3Configuration:
        bucketArn: "arn:aws:s3:::company-docs"
        inclusionPrefixes: ["faq/"]
      chunkingConfiguration:
        chunkingStrategy: "FIXED_SIZE"
        fixedSizeChunkingConfiguration:
          maxTokens: 512
          overlapPercentage: 20
  
  tags:
    Environment: "dev"
    Project: "company-kb"
EOF
```

**Step 2: Link Agent to Knowledge Base**
```bash
# Create agent-kb-association.yml
cat > agent-kb-association.yml << 'EOF'
kind: AgentKnowledgeBaseAssociation
metadata:
  name: "weather-agent-faq-link"
  description: "Link weather agent to company FAQ"
spec:
  agentName: "weather-agent"
  knowledgeBaseName: "company-faq"
  description: "Company FAQ for weather agent"
  state: "ENABLED"
EOF
```

### Complete Deployment Workflow

**Step 1: Validate All Resources**
```bash
bedrock-forge validate .
```

**Step 2: Generate Terraform**
```bash
bedrock-forge generate . ./terraform
```

**Step 3: Review Generated Terraform**
```bash
ls ./terraform/
# main.tf - Generated Terraform configuration
# variables.tf - Input variables
# outputs.tf - Module outputs
```

**Step 4: Deploy Infrastructure**
```bash
cd terraform
terraform init
terraform plan
terraform apply
```

**Step 5: Test Your Agent**
```bash
# Use AWS CLI or Console to test agent
aws bedrock-agent-runtime invoke-agent \
  --agent-id <agent-id> \
  --agent-alias-id <alias-id> \
  --session-id test-session \
  --input-text "What's the weather like in London?"
```

### Best Practices for Getting Started

1. **Start Simple**: Begin with a basic agent, then add features incrementally
2. **Use Validation**: Always run `bedrock-forge validate` before generation
3. **Version Control**: Keep YAML configurations in Git for tracking changes
4. **Environment Separation**: Use different directories for dev/staging/prod
5. **Test Locally**: Validate YAML and Terraform generation before deployment
6. **Monitor Costs**: Be aware of AWS Bedrock pricing for foundation models
7. **Security**: Use appropriate IAM roles and don't commit sensitive data

## IAM Management

**🎉 IAM roles are automatically generated for all Bedrock resources!** No manual configuration required.

Every Bedrock resource gets appropriate IAM permissions automatically:
- **Agents**: Foundation model access, Lambda invocation, knowledge base access, CloudWatch logging
- **Lambda Functions**: Execution roles with VPC access and CloudWatch logging
- **Action Groups**: Inherit permissions from associated agent roles
- **Knowledge Bases**: S3 access and OpenSearch operations

### Auto-Generated Agent IAM Roles

When you create an Agent, Bedrock Forge automatically generates:
1. **IAM Role**: `bedrock-agent-{agent-name}-role`
2. **IAM Policy**: `bedrock-agent-{agent-name}-policy`

#### Foundation Model Access
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "bedrock:InvokeModel",
        "bedrock:InvokeModelWithResponseStream",
        "bedrock:GetInferenceProfile",
        "bedrock:ListInferenceProfiles", 
        "bedrock:UseInferenceProfile"
      ],
      "Resource": "*"
    }
  ]
}
```

#### Lambda Invocation (for Action Groups)
Auto-generated when agents reference Lambda functions:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["lambda:InvokeFunction"],
      "Resource": "arn:aws:lambda:region:account:function:function-name"
    }
  ]
}
```

#### Knowledge Base Access
Auto-generated when agents are associated with knowledge bases:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "bedrock:Retrieve",
        "bedrock:RetrieveAndGenerate"
      ],
      "Resource": "arn:aws:bedrock:region:account:knowledge-base/*"
    }
  ]
}
```

#### CloudWatch Logging
Always included for debugging and monitoring:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    }
  ]
}
```

### Lambda Resource-Based Policies

Lambda functions automatically get resource-based policies allowing Bedrock agent invocation:

#### Agent-Specific Permissions
When agents reference Lambda functions, automatic creation of agent-specific permissions:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {"Service": "bedrock.amazonaws.com"},
      "Action": "lambda:InvokeFunction",
      "Resource": "arn:aws:lambda:region:account:function:function-name",
      "Condition": {
        "StringEquals": {
          "aws:SourceArn": "arn:aws:bedrock:region:account:agent/agent-id"
        }
      }
    }
  ]
}
```

#### General Bedrock Permissions
For Lambda functions not yet referenced by agents:
```json
{
  "Version": "2012-10-17", 
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {"Service": "bedrock.amazonaws.com"},
      "Action": "lambda:InvokeFunction",
      "Resource": "arn:aws:lambda:region:account:function:function-name"
    }
  ]
}
```

### Custom IAM Configuration

For enterprise scenarios requiring specific permissions, you can define custom IAM roles:

#### Manual IAM Role Resource
```yaml
kind: IAMRole
metadata:
  name: "custom-agent-role"
  description: "Custom IAM role for enterprise agent"
spec:
  assumeRolePolicy:
    version: "2012-10-17"
    statement:
      - effect: "Allow"
        principal:
          service: "bedrock.amazonaws.com"
        action: "sts:AssumeRole"
  policies:
    - policyArn: "arn:aws:iam::aws:policy/service-role/AmazonBedrockAgentResourcePolicy"
  inlinePolicies:
    - name: "CustomBedrockAccess"
      policy:
        version: "2012-10-17"
        statement:
          - effect: "Allow"
            action: ["bedrock:InvokeModel"]
            resource: "arn:aws:bedrock:*::foundation-model/anthropic.*"
  tags:
    Purpose: "BedrockAgent"
    Compliance: "SOC2"
```

#### Custom Lambda Resource Policy
For advanced scenarios, Lambda functions can include custom resource policies:
```yaml
kind: Lambda
metadata:
  name: "secure-lambda"
spec:
  runtime: "python3.11"
  handler: "app.handler"
  code:
    source: "directory"
  
  # Optional: Custom resource policy for advanced scenarios
  resourcePolicy:
    version: "2012-10-17"
    statement:
      - effect: "Allow"
        principal:
          service: "bedrock.amazonaws.com"
        action: "lambda:InvokeFunction"
        condition:
          StringEquals:
            "aws:SourceAccount": "123456789012"
      - effect: "Allow"
        principal:
          aws: "arn:aws:iam::456789012345:root"  # Cross-account access
        action: "lambda:InvokeFunction"
```

### IAM Best Practices

#### Development Environment
- Use auto-generated IAM roles for simplicity
- Rely on default permissions for rapid prototyping
- Monitor CloudWatch logs for permission issues

#### Production Environment
- Review auto-generated policies before deployment
- Consider custom IAM roles for compliance requirements
- Implement least-privilege access controls
- Use resource-specific ARNs instead of wildcards

#### Enterprise Compliance
- Define custom IAM roles with organization-specific policies
- Include mandatory tags for cost allocation and compliance
- Implement cross-account access controls for shared resources
- Use AWS IAM Access Analyzer to validate permissions

#### Security Monitoring
- Enable CloudTrail for IAM policy changes
- Monitor unusual API calls in CloudWatch
- Implement alerting for permission errors
- Regular audit of generated IAM policies

### Troubleshooting IAM Issues

#### Common Permission Errors
1. **Agent can't invoke foundation models**: Check Bedrock service availability in region
2. **Action group Lambda failures**: Verify Lambda resource-based policy exists
3. **Knowledge base access denied**: Confirm agent-KB association exists
4. **Cross-account access issues**: Review resource-based policies and trust relationships

#### Debug Commands
```bash
# Check generated IAM policies
aws iam get-role-policy --role-name bedrock-agent-{agent-name}-role --policy-name bedrock-agent-{agent-name}-policy

# Verify Lambda resource policy
aws lambda get-policy --function-name {function-name}

# List agent permissions
aws bedrock describe-agent --agent-id {agent-id}
```

## Key Capabilities

### Dependency Management
Resources are automatically ordered and resolved:
1. **IAMRole** → **Guardrail** → **Prompt** → **Lambda** → **OpenSearchServerless** → **KnowledgeBase** → **ActionGroup** → **Agent**
2. Cross-resource references use Terraform module outputs (e.g., `${module.guardrail.guardrail_id}`)
3. Validation ensures all referenced resources exist before generation

### Artifact Packaging
- **Lambda Functions**: Automatic ZIP packaging of co-located code directories
- **OpenAPI Schemas**: Upload to S3 with versioned keys for Action Group integration
- **S3 Management**: Unique artifact keys using timestamp + content hash

## Generated Terraform Example

```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

variable "project_name" {
  description = "Name of the project"
  type        = string
  default     = "bedrock-forge"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "dev"
}

module "content_safety_guardrail" {
  source = "git::https://github.com/org/terraform-modules//bedrock-guardrail?ref=v1.0.0"
  
  name        = "content-safety-guardrail"
  description = "Enterprise content safety guardrail"
  
  content_policy_config = {
    filters_config = [
      {
        type            = "SEXUAL"
        input_strength  = "HIGH"
        output_strength = "HIGH"
      }
    ]
  }
  
  tags = {
    Environment = var.environment
    Project     = var.project_name
  }
}

module "customer_support_agent" {
  source = "git::https://github.com/org/terraform-modules//bedrock-agent?ref=v1.0.0"
  
  name               = "customer-support"
  foundation_model   = "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction        = "You are a helpful customer support agent..."
  
  guardrail_id      = module.content_safety_guardrail.guardrail_id
  knowledge_base_id = module.faq_kb.knowledge_base_id
  
  tags = {
    Environment = var.environment
    Project     = var.project_name
  }
}

output "agent_arn" {
  description = "ARN of the created Bedrock agent"
  value       = module.customer_support_agent.agent_arn
}
```

### Enterprise Governance
- **Naming Conventions**: Enforce patterns like `{team}-{environment}-{name}-{type}`
- **Tagging Policies**: Require tags for cost allocation, compliance, and ownership
- **Security Validation**: IAM policy scanning, Lambda security requirements, network policies
- **Multi-Environment**: Different validation profiles for dev/staging/production

## Enterprise Validation Features

**Naming Convention Enforcement:**
- Flexible patterns: `{team}-{environment}-{name}-{type}`
- Example: `data-prod-customer-support-agent`
- Regex-based validation with team-specific rules

**Mandatory Tagging:**
```yaml
# Required enterprise tags
tags:
  Environment: "prod"                    # Environment identifier
  Project: "customer-support-platform"  # Project name
  Owner: "john.doe@company.com"         # Resource owner
  CostCenter: "CC-123456"               # Cost allocation
  Team: "data"                          # Organizational team
  BusinessUnit: "engineering"           # Business unit
  DataClassification: "internal"        # Data sensitivity
  ComplianceLevel: "pci"                # Compliance requirements
```

**Security Policy Validation:**
- IAM policy scanning for forbidden actions and MFA requirements
- Lambda security validation (VPC, timeouts, runtime versions)
- Agent security requirements (guardrails, encryption, memory configuration)
- Network security validation for VPC and security group configurations

## GitHub Actions Integration

**Reusable Workflow for Validation & Deployment:**

The project includes a comprehensive GitHub Actions workflow (`bedrock-forge-deploy.yml`) that provides:

**Workflow Features:**
- **Validation-First Approach**: Defaults to validation-only mode for cost-effective testing
- **Multi-stage Pipeline**: Validate → Package → Deploy → Cleanup (conditional)
- **Resource Scanning**: Automatic discovery of Lambda functions, schemas, and Bedrock resources
- **Artifact Management**: Automated packaging of Lambda code and OpenAPI schemas (when deploying)
- **Environment Support**: Dev, staging, and production with different validation levels
- **Dry Run Mode**: Plan-only mode for reviewing changes before deployment
- **State Management**: S3 backend with DynamoDB locking for Terraform state

**Usage in Your Repository:**

**Validation-Only Mode (Default - No AWS Costs):**
```yaml
name: Validate Bedrock Configurations
on:
  push:
    branches: [main, develop]
    paths: ['agents/**', 'lambdas/**', 'action-groups/**', 'knowledge-bases/**']
  pull_request:
    paths: ['agents/**', 'lambdas/**', 'action-groups/**', 'knowledge-bases/**']

jobs:
  validate:
    uses: ./.github/workflows/bedrock-forge-deploy.yml
    with:
      validation_only: true  # Default: true (no deployment, no AWS costs)
      source_path: '.'
    # No secrets needed for validation-only mode
```

**Full Deployment Mode:**
```yaml
name: Deploy Bedrock Agents
on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options: ['dev', 'staging', 'prod']
      dry_run:
        description: 'Run in dry-run mode'
        required: false
        default: false
        type: boolean

jobs:
  deploy:
    uses: ./.github/workflows/bedrock-forge-deploy.yml
    with:
      validation_only: false  # Enable deployment
      environment: ${{ github.event.inputs.environment || 'dev' }}
      aws_region: 'us-east-1'
      aws_role: 'arn:aws:iam::123456789012:role/bedrock-forge-deploy-role'
      tf_state_bucket: 'my-terraform-state-bucket'
      tf_state_key_prefix: 'bedrock-forge'
      tf_state_lock_table: 'terraform-state-lock'
      dry_run: ${{ github.event.inputs.dry_run || false }}
      source_path: '.'
    secrets: inherit
```

**Parameters:**

**Always Optional:**
- `validation_only`: Run validation only without deployment (default: true)
- `source_path`: Path to YAML configurations (default: .)
- `terraform_version`: Terraform version (default: 1.5.0)
- `go_version`: Go version for building Bedrock Forge (default: 1.21)
- `bedrock_forge_version`: Version/ref of Bedrock Forge to use (default: main)

**Required for Deployment (when validation_only is false):**
- `aws_role`: IAM role ARN for deployment
- `tf_state_bucket`: S3 bucket for Terraform state storage
- `environment`: Target environment (dev/staging/prod)
- `aws_region`: AWS region for deployment

**Optional for Deployment:**
- `tf_state_key_prefix`: Key prefix for Terraform state (default: bedrock-forge)
- `tf_state_lock_table`: DynamoDB table for state locking
- `aws_session_name`: AWS session name for assumed role (default: bedrock-forge-deploy)
- `dry_run`: Plan-only mode without applying changes (default: false)

**Multi-Environment Support:**

**Validation-Only Mode (Default):**
- **All Environments**: Fast validation, no AWS costs, runs on every push/PR
- **Immediate Feedback**: Catch configuration errors before deployment
- **Cost-Effective**: No AWS resources created, no deployment charges

**Deployment Mode (Optional):**
- **Development**: Minimal validation, rapid iteration, manual trigger
- **Staging**: Full validation, integration testing, manual approval
- **Production**: Enterprise validation, approval workflows, protected branches

**Security Features:**
- **No Credentials for Validation**: Validation-only mode requires no AWS credentials
- **AWS OIDC Authentication**: No long-lived credentials for deployment
- **IAM Roles with Least Privilege**: Environment-specific role assumption
- **State Management**: Secure S3 backend with DynamoDB locking
- **Artifact Isolation**: Environment-specific artifact storage
- **Approval Workflows**: Manual approval gates for production deployments

**Pipeline Stages:**
1. **Validate**: YAML syntax validation and resource scanning (always runs)
2. **Package**: Lambda code packaging and schema uploads (only when deploying)
3. **Deploy**: Terraform planning and application with state management (only when deploying)
4. **Summary**: Pipeline summary and results (always runs)

## Usage Patterns

**Resource References:**
```yaml
# Reference other resources by name in YAML configurations
spec:
  guardrail:
    name: "content-safety-guardrail"  # References Guardrail resource
  actionGroups:
    - name: "order-management"        # References ActionGroup resource
```

**Lambda Function References:**
```yaml
# Option 1: Reference Lambda defined in same project
actionGroupExecutor:
  lambda: "order-lookup"  # References local Lambda resource

# Option 2: Reference existing Lambda by ARN (shared Lambda)
actionGroupExecutor:
  lambdaArn: "arn:aws:lambda:us-east-1:123456789012:function:shared-service"
```

**Environment-Specific Configurations:**
```yaml
# Configure different values per environment
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  idleSessionTtlInSeconds: 3600  # Production: longer sessions
  # Development might use: 300 seconds for faster iteration
```

**Artifact Management:**
- **Lambda Code**: Co-locate source code with YAML files for automatic packaging
- **OpenAPI Schemas**: Provide manual schema files for automatic S3 upload
- **Versioning**: Automatic unique keys using timestamp + content hash

**Cross-Resource Dependencies:**
- Validation ensures all referenced resources exist before generation
- Resources are generated in proper dependency order automatically
- Terraform module outputs handle cross-resource references seamlessly

## Recent Feature Enhancements

**Enhanced Prompt Resource (Latest Update):**

The Prompt resource has been significantly enhanced to support all AWS Bedrock Terraform provider features:

**New Capabilities:**
- **Input Variables**: Define and use variables like `{{query}}`, `{{context}}`, `{{user_name}}` in templates
- **CHAT Template Type**: Support for conversational templates with system messages, user/assistant exchanges
- **Tool Calling**: Function calling capabilities with JSON schemas and tool choice strategies
- **Customer Encryption**: KMS key support for sensitive prompt templates
- **Enhanced Inference**: Added topK parameter, better parameter handling with pointers
- **Template-Level Variables**: Variables can be defined globally or per-template for flexibility

**Key Features:**
1. **Dual Template Types**: TEXT (simple prompts) and CHAT (conversational with tools)
2. **Variable Management**: Proper scope and validation for prompt variables
3. **Function Calling**: Complete tool configuration with auto/any/specific tool choices
4. **Agent Association**: Direct integration with agents via genAiResource configuration
5. **Security**: Optional KMS encryption for sensitive enterprise prompts
6. **Backward Compatibility**: Existing TEXT prompts continue to work unchanged

**Use Cases:**
- **TEXT Templates**: Simple prompts with variable substitution for agent orchestration
- **CHAT Templates**: Complex conversational agents with tool access and multi-turn dialogs
- **Function Calling**: Agents that can call external APIs, search knowledge bases, or execute actions
- **Agent Integration**: Prompts directly associated with specific agents for consistent behavior
- **Enterprise Security**: Encrypted prompts for sensitive business logic and proprietary instructions

**Migration Path:**
- Existing prompts continue to work without changes
- New features are opt-in through updated YAML structure
- Enhanced generator handles both old and new formats seamlessly

**Enhanced Lambda Resource-Based Policies (Current Update):**

bedrock-forge now provides comprehensive management of Lambda function resource-based policies for Bedrock agent integration:

**New Capabilities:**
- **Automatic Permission Management**: Default `bedrock.amazonaws.com` invoke permissions on all Lambda functions
- **Agent-Specific Permissions**: Auto-generated `aws_lambda_permission` resources with source ARN restrictions per agent
- **Custom Resource Policies**: Full control over Lambda resource-based policies through YAML configuration
- **Security Best Practices**: Account-specific and cross-account access controls with condition support
- **Dependency Management**: Proper Terraform ordering between agents, Lambda functions, and permissions

**Key Features:**
1. **Default Security**: Every Lambda gets basic Bedrock service permissions automatically
2. **Enhanced Security**: Agent-specific permissions with `arn:aws:bedrock:region:account:agent/agent-id` source ARN patterns
3. **Custom Policies**: Additional policy statements for enterprise scenarios (cross-account access, etc.)
4. **Zero Configuration**: Works out-of-the-box for simple agent-to-Lambda scenarios
5. **Enterprise Control**: Full policy customization for complex organizational requirements

**Use Cases:**
- **Simple Agents**: Default permissions handle basic agent-to-Lambda invocation automatically
- **Multi-Agent Systems**: Each agent gets specific permissions to only invoke its referenced Lambda functions
- **Cross-Account Access**: Custom policies for shared Lambda functions across AWS accounts
- **Enterprise Compliance**: Account restrictions and conditional access for organizational security standards

**Implementation Details:**
- **Zero-Configuration Default**: Lambda functions require no resource policy configuration - permissions are handled automatically
- **Intelligent Agent Detection**: Lambda generator scans all agents during generation to detect references and create appropriate permissions
- **Agent-Specific Security**: Each agent gets permissions only for Lambda functions it actually references, with source ARN restrictions
- **Automatic Policy Generation**: Resource-based policies are created directly in the Lambda module, eliminating separate permission resources
- **Optional Customization**: Advanced users can still add custom `resourcePolicy` statements for enterprise scenarios

## Enterprise Validation Guide

Bedrock Forge provides comprehensive enterprise-grade validation capabilities that enforce organizational standards for resource naming, tagging, and security compliance.

### Validation Profiles

#### Default Profile
Development-friendly validation with basic checks:
- Basic YAML syntax validation
- Resource dependency validation
- Simple naming pattern checks
- Optional tagging requirements

#### Enterprise Profile
Production-ready validation with strict governance policies:
- **Resource Naming Convention Enforcement**: Flexible regex patterns, team-specific rules, environment-aware naming
- **Mandatory Tagging**: Cost allocation, compliance tracking, resource-specific requirements
- **Security Policy Validation**: IAM policy scanning, Lambda security, agent security, network security
- **Comprehensive Coverage**: All resource types with organizational standards

#### Custom Profile
User-defined validation rules via configuration file for organization-specific requirements.

### Enterprise Validation Configuration

#### Naming Convention Enforcement
```yaml
# validation.yml
profiles:
  enterprise:
    naming:
      patterns:
        agent: "^[a-z][a-z0-9-]*-agent$"
        lambda: "^[a-z][a-z0-9-]*-lambda$"
        action_group: "^[a-z][a-z0-9-]*-ag$"
      team_specific:
        data_team: "^data-.*"
        ml_team: "^ml-.*"
```

#### Mandatory Tagging
```yaml
# Required enterprise tags
validation:
  tagging:
    required_tags:
      - Environment    # Environment identifier
      - Project        # Project name
      - Owner          # Resource owner email
      - CostCenter     # Cost allocation
      - Team           # Organizational team
      - BusinessUnit   # Business unit
      - DataClassification  # Data sensitivity
      - ComplianceLevel     # Compliance requirements
    
    patterns:
      Owner: "^[a-z.]+@company\\.com$"
      Environment: "^(dev|staging|prod)$"
```

#### Security Policy Validation
```yaml
validation:
  security:
    iam:
      forbidden_actions:
        - "*:*"
        - "iam:*"
        - "sts:AssumeRole"
      require_mfa: true
    
    lambda:
      require_vpc: true
      max_timeout: 900
      allowed_runtimes:
        - "python3.11"
        - "python3.12"
        - "nodejs18.x"
        - "nodejs20.x"
    
    agent:
      require_guardrails: true
      require_encryption: true
      max_session_ttl: 3600
```

### Using Enterprise Validation

#### Command Line Usage
```bash
# Use enterprise validation profile
bedrock-forge validate . --profile enterprise

# Use custom validation configuration
bedrock-forge validate . --profile custom --config ./enterprise-validation.yml

# Generate with enterprise validation
bedrock-forge generate . ./terraform --profile enterprise
```

#### CI/CD Integration
```yaml
# .github/workflows/ci.yml
name: Enterprise Validation
on: [push, pull_request]

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Validate Bedrock Configurations
        uses: ./.github/workflows/bedrock-forge-deploy.yml
        with:
          validation_only: true
          validation_profile: enterprise
          source_path: '.'
```

### Enterprise Tagging Examples

#### Development Environment
```yaml
tags:
  Environment: "dev"
  Project: "customer-support-ai"
  Owner: "john.doe@company.com"
  CostCenter: "CC-123456"
  Team: "ai-platform"
  BusinessUnit: "engineering"
  DataClassification: "internal"
  ComplianceLevel: "standard"
```

#### Production Environment
```yaml
tags:
  Environment: "prod"
  Project: "customer-support-ai"
  Owner: "ai-team@company.com"
  CostCenter: "CC-789012"
  Team: "ai-platform"
  BusinessUnit: "engineering"
  DataClassification: "confidential"
  ComplianceLevel: "pci-dss"
  BackupRequired: "true"
  MonitoringLevel: "high"
```

### Security Best Practices

#### Agent Security Requirements
```yaml
# Enterprise agent with security controls
kind: Agent
metadata:
  name: "secure-customer-agent"
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are a secure customer support agent..."
  
  # Required: Guardrail for content safety
  guardrail:
    name: "enterprise-content-guardrail"
    version: "2"
    mode: "pre"
  
  # Required: Customer encryption key
  customerEncryptionKey: "arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012"
  
  # Required: Session timeout limits
  idleSessionTtlInSeconds: 1800  # 30 minutes max
  
  # Required: Memory configuration
  memoryConfiguration:
    enabledMemoryTypes: ["SESSION_SUMMARY"]
    storageDays: 7  # Limited retention
```

#### Lambda Security Requirements
```yaml
# Enterprise Lambda with security controls
kind: Lambda
metadata:
  name: "secure-order-processor"
spec:
  runtime: "python3.11"  # Approved runtime
  handler: "app.handler"
  timeout: 300  # Under enterprise limit
  
  # Required: VPC configuration
  vpcConfig:
    securityGroupIds: ["sg-12345678"]
    subnetIds: ["subnet-12345678", "subnet-87654321"]
  
  # Required: Environment encryption
  kmsKeyArn: "arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012"
  
  # Required: Dead letter queue
  deadLetterConfig:
    targetArn: "arn:aws:sqs:us-east-1:123456789012:dlq-queue"
```

### Validation Error Examples

#### Naming Convention Violations
```
ERROR: Agent name 'CustomerSupport' violates naming convention
Expected pattern: ^[a-z][a-z0-9-]*-agent$
Suggestion: customer-support-agent
```

#### Missing Required Tags
```
ERROR: Missing required tags on resource 'customer-agent'
Missing tags: Owner, CostCenter, ComplianceLevel
Required for enterprise deployment
```

#### Security Policy Violations
```
ERROR: Lambda function timeout exceeds enterprise limit
Current: 900 seconds, Maximum allowed: 600 seconds
Update timeout or request security exception
```

### Multi-Environment Validation

#### Development
- **Relaxed Naming**: Flexible patterns for rapid iteration
- **Optional Tags**: Basic tagging requirements
- **Minimal Security**: Basic security controls

#### Staging
- **Stricter Naming**: Production-like naming patterns
- **Required Tags**: Full tagging compliance
- **Enhanced Security**: Production security controls

#### Production
- **Strict Naming**: Full enterprise naming compliance
- **Mandatory Tags**: Complete cost allocation and compliance tags
- **Maximum Security**: All security controls required, encryption mandatory

---

This guide provides AI assistants with essential context about Bedrock Forge's capabilities, YAML schema patterns, CLI usage, and enterprise features to effectively help developers work with the platform.