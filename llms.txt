# Bedrock Forge

Bedrock Forge is an enterprise platform that transforms YAML configurations into AWS Bedrock agent deployments using Terraform modules. It provides a declarative, YAML-driven approach for deploying AWS Bedrock services with automatic IAM management, dependency resolution, and integrated CI/CD workflows.

## Core Features

**Infrastructure as Code:**
- YAML to Terraform conversion with automatic module generation
- Comprehensive dependency management and resource ordering
- Automatic IAM role generation with appropriate permissions
- Cross-resource references and validation
- Automatic output directory creation (`outputs_tf`) for generated files

**CI/CD Integration:**
- Separate validation and deployment GitHub Actions workflows
- S3-based artifact storage with commit hash organization
- Terraform plan visibility in pull request comments
- Environment-specific deployments with approval workflows

**Enterprise Capabilities:**
- Support for user's own Terraform files via CustomResources
- Automated Lambda code packaging and deployment
- OpenAPI schema management for Action Groups
- Enterprise governance and tagging enforcement
- Enhanced tag validation with proper null handling

## Reference Syntax

Bedrock Forge supports two syntax formats for cross-resource references:

**Object Syntax (Recommended):**
```yaml
lambda: {ref: lambda-name}
aguardrail:
  name: {ref: guardrail-name}
```

**String Syntax (Legacy):**
```yaml
lambda: "lambda-name"
guardrail:
  name: "guardrail-name"
```

Both syntaxes are functionally equivalent. The object syntax provides better IDE support and validation, while the string syntax offers more concise YAML. Choose the style that best fits your team's preferences.

## CLI Commands

### Generate Command

```bash
bedrock-forge generate [path] [output-dir]
```

**Arguments:**
- `path`: Path to directory containing YAML files (default: current directory)
- `output-dir`: Output directory for generated Terraform files (default: `outputs_tf`)

**Examples:**
```bash
# Generate from current directory to outputs_tf
bedrock-forge generate

# Generate from specific directory
bedrock-forge generate examples/

# Generate with custom output directory
bedrock-forge generate examples/ my-terraform/
```

**Features:**
- Automatically creates the output directory if it doesn't exist
- Generates `main.tf` with all resources and proper dependencies
- Copies CustomResources .tf files to the output directory
- Creates variables files for CustomResources with provided variables
- Validates all cross-references before generation

### Other Commands

```bash
# Scan and list all resources
bedrock-forge scan [path]

# Validate YAML syntax and dependencies
bedrock-forge validate [path]

# Show version information
bedrock-forge version
```

## Supported Resources

### 1. Agent - AWS Bedrock Conversational Agents

```yaml
kind: Agent
metadata:
  name: string (required)
  description: string (optional)
spec:
  foundationModel: string (required) # e.g., "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: string (required)
  description: string (optional)
  idleSessionTtl: int (optional)
  customerEncryptionKey: string (optional)
  tags: map[string]string (optional)
  
  # Guardrail configuration
  guardrail: (optional)
    name: {ref: guardrail-name} | "guardrail-name" # Reference to Guardrail resource
    version: string (optional)
    mode: string (optional)
  
  # Inline action groups (preferred approach)
  actionGroups: (optional)
    - name: string (required)
      description: string (optional)
      parentActionGroupSignature: string (optional)
      actionGroupState: string (optional)
      skipResourceInUseCheck: bool (optional)
      actionGroupExecutor: (optional)
        lambda: {ref: lambda-name} | "lambda-name" # Reference to Lambda resource
        lambdaArn: string (optional) # Direct Lambda ARN
        customControl: string (optional)
      apiSchema: (optional)
        s3:
          s3BucketName: string (required)
          s3ObjectKey: string (required)
        payload: string (optional)
      functionSchema: (optional)
        functions:
          - name: string (required)
            description: string (optional)
            parameters:
              paramName:
                description: string (optional)
                required: bool (optional)
                type: string (optional)
  
  # Prompt overrides
  promptOverrides: (optional)
    - promptType: string (required)
      promptArn: string (optional)
      prompt: {ref: prompt-name} | "prompt-name" # Reference to Prompt resource
      promptVariant: string (optional)
      variant: string (optional)
  
  # Memory configuration
  memoryConfiguration: (optional)
    enabledMemoryTypes: []string (optional)
    storageDays: int (optional)
  
  # Agent aliases for environment management
  aliases: (optional)
    - name: string (required)
      description: string (optional)
      tags: map[string]string (optional)
  
  # IAM Role configuration (allows users to specify existing roles or customize auto-generated ones)
  iamRole: (optional)
    autoCreate: bool (optional) # Default: true
    roleArn: string (optional) # For existing role ARN
    roleName: {ref: role-name} | "role-name" (optional) # Reference to IAMRole resource
    additionalPolicies: (optional)
      - policyArn: string (required)
        policyName: {ref: policy-name} | "policy-name" (optional)
```

**Key Features:**
- **Flexible IAM role management**: Auto-generate roles (default) or use existing IAM roles
- **Refined Lambda permissions**: Uses specific Lambda ARNs instead of wildcards for better security
- Inline action groups with Lambda integration (no separate ActionGroup resources needed)
- Guardrail and prompt integration via references
- Agent aliases for environment-specific deployments
- Cross-resource dependency management

**IAM Role Configuration:**
```yaml
# Option 1: Auto-generate IAM role (default behavior)
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are a helpful assistant"
  # No iamRole specified - auto-generates with appropriate permissions

# Option 2: Use existing IAM role ARN
spec:
  iamRole:
    roleArn: "arn:aws:iam::123456789012:role/ExistingBedrockAgentRole"

# Option 3: Reference custom IAMRole resource
spec:
  iamRole:
    roleName: {ref: custom-agent-execution-role}

# Option 4: Auto-create with additional policies
spec:
  iamRole:
    autoCreate: true
    additionalPolicies:
      - policyArn: "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess"

# Option 5: Explicitly disable auto-creation (requires existing role)
spec:
  iamRole:
    autoCreate: false
    roleArn: "arn:aws:iam::123456789012:role/ExistingBedrockAgentRole"
```

### 2. Lambda - AWS Lambda Functions for Action Groups

```yaml
kind: Lambda
metadata:
  name: string (required)
  description: string (optional)
spec:
  runtime: string (required) # e.g., "python3.9", "nodejs18.x"
  handler: string (required) # e.g., "app.handler"
  code: (required)
    source: string (required) # "directory", "zip", "s3"
    zipFile: string (optional) # For inline code
    s3Bucket: string (optional) # For S3-based code
    s3Key: string (optional)
    s3ObjectVersion: string (optional)
  environment: map[string]string (optional)
  timeout: int (optional) # Default: 3 seconds
  memorySize: int (optional) # Default: 128 MB
  reservedConcurrency: int (optional)
  tags: map[string]string (optional)
  vpcConfig: (optional)
    securityGroupIds: []string (required)
    subnetIds: []string (required)
  
  # Resource policy (optional - auto-generated based on agent references)
  resourcePolicy: (optional)
    allowBedrockAgents: bool (optional)
    statements:
      - sid: string (required)
        effect: string (required)
        principal: map[string]interface{} (required)
        action: string|[]string (required)
        resource: string (optional)
        condition: map[string]interface{} (optional)
```

**Key Features:**
- **Automatic IAM execution role generation** with refined permissions
- **Smart S3 permissions**: Automatically adds S3 policies when environment variables reference S3 buckets
- Code packaging and S3 deployment
- Zero-configuration resource policies (auto-detects agent references)
- Agent-specific permissions with source ARN restrictions
- VPC integration support

**Automatic Permission Detection:**
```yaml
# Lambda with S3 bucket reference in environment variables
spec:
  environment:
    S3_BUCKET: "${aws_s3_bucket.document_storage_bucket.bucket}"
    LOG_LEVEL: "INFO"
# bedrock-forge automatically detects S3 reference and adds appropriate IAM policies:
# - s3:GetObject, s3:PutObject, s3:DeleteObject on bucket contents
# - s3:ListBucket, s3:GetBucketLocation on bucket itself
```

### 3. ActionGroup - Standalone Action Groups (Alternative to Inline)

```yaml
kind: ActionGroup
metadata:
  name: string (required)
  description: string (optional)
spec:
  agentId: {ref: agent-name} | "agent-name" # Reference to Agent resource
  agentVersion: string (optional) # Default: "DRAFT"
  description: string (optional)
  parentActionGroupSignature: string (optional)
  actionGroupState: string (optional)
  skipResourceInUseCheck: bool (optional)
  tags: map[string]string (optional)
  
  # Required executor configuration
  actionGroupExecutor: (required)
    lambda: {ref: lambda-name} | "lambda-name" # Reference to Lambda resource
    lambdaArn: string (optional) # Direct Lambda ARN
    customControl: string (optional)
  
  # API or Function schema (mutually exclusive)
  apiSchema: (optional)
    s3:
      s3BucketName: string (required)
      s3ObjectKey: string (required)
    payload: string (optional)
  
  functionSchema: (optional)
    functions:
      - name: string (required)
        description: string (optional)
        parameters:
          paramName:
            description: string (optional)
            required: bool (optional)
            type: string (optional)
```

**Note:** Inline action groups in Agent resources are the preferred approach. Use standalone ActionGroups only when you need to deploy action groups separately from agents.

### 4. KnowledgeBase - Vector Knowledge Bases with Data Sources

```yaml
kind: KnowledgeBase
metadata:
  name: string (required)
  description: string (optional)
spec:
  description: string (optional)
  tags: map[string]string (optional)
  
  # Knowledge base configuration
  knowledgeBaseConfiguration: (optional)
    type: string (required) # "VECTOR"
    vectorKnowledgeBaseConfiguration: (optional)
      embeddingModelArn: string (required)
      embeddingModelConfiguration: (optional)
        bedrockEmbeddingModelConfiguration: (optional)
          dimensions: int (optional)
  
  # Storage configuration (enhanced approach)
  storageConfiguration: (optional)
    type: string (required) # "OPENSEARCH_SERVERLESS"
    openSearchServerless: (optional)
      collectionArn: string (optional) # Existing collection
      collectionId: string (optional)
      collectionName: {ref: collection-name} | "collection-name" # Reference to OpenSearchServerless resource
      vectorIndexName: string (required)
      fieldMapping:
        vectorField: string (required)
        textField: string (required)
        metadataField: string (required)
  
  # Data sources
  dataSources: (optional)
    - name: string (required)
      type: string (required) # "S3"
      s3Configuration: (optional)
        bucketArn: string (required)
        inclusionPrefixes: []string (optional)
        exclusionPrefixes: []string (optional)
      chunkingConfiguration: (optional)
        chunkingStrategy: string (required) # "FIXED_SIZE", "NONE", "SEMANTIC"
        fixedSizeChunkingConfiguration: (optional)
          maxTokens: int (required)
          overlapPercentage: int (required)
        semanticChunkingConfiguration: (optional)
          maxTokens: int (required)
          bufferSize: int (required)
          breakpointPercentileThreshold: int (required)
      customTransformation: (optional)
        transformationLambda: (optional)
          lambdaArn: string (optional) # Direct Lambda ARN
          lambda: {ref: lambda-name} | "lambda-name" # Reference to Lambda resource
        intermediateStorage: (optional)
          s3Location: (optional)
            uri: string (required)
```

**Key Features:**
- Integration with OpenSearchServerless collections (auto-created or existing)
- Multiple data source types with advanced chunking strategies
- Custom transformation support via Lambda
- Vector embedding model configuration

### 5. Prompt - Custom Prompt Templates with Tool Calling

```yaml
kind: Prompt
metadata:
  name: string (required)
  description: string (optional)
spec:
  description: string (optional)
  defaultVariant: string (optional)
  customerEncryptionKeyArn: string (optional) # KMS encryption
  tags: map[string]string (optional)
  
  # Prompt-level input variables
  inputVariables: (optional)
    - name: string (required)
  
  # Prompt variants (required)
  variants: (required)
    - name: string (required)
      modelId: string (required)
      templateType: string (required) # "TEXT" or "CHAT"
      
      # Template configuration
      templateConfiguration: (optional)
        # For TEXT template type
        text: (optional)
          text: string (required) # Template with {{variables}}
          inputVariables: (optional)
            - name: string (required)
        
        # For CHAT template type
        chat: (optional)
          messages: (optional)
            - role: string (required) # "user", "assistant", "system"
              content:
                - text: string (optional)
          system: (optional)
            - text: string (required)
          inputVariables: (optional)
            - name: string (required)
          toolConfiguration: (optional) # Function calling
            tools: (optional)
              - toolSpec: (optional)
                  name: string (required)
                  description: string (required)
                  inputSchema: (optional)
                    json: map[string]any (optional)
            toolChoice: (optional)
              auto: {} (optional)
              any: {} (optional)
              tool: (optional)
                name: string (required)
      
      # Inference configuration
      inferenceConfiguration: (optional)
        text: (optional)
          temperature: float64 (optional)
          topP: float64 (optional)
          topK: int (optional)
          maxTokens: int (optional)
          stopSequences: []string (optional)
      
      # Gen AI Resource (Agent integration)
      genAiResource: (optional)
        agent: (optional)
          agentName: {ref: agent-name} | "agent-name" # Reference to Agent resource
          agentArn: string (optional) # Direct ARN
```

**Key Features:**
- Support for both TEXT and CHAT template types
- Input variables with {{variable}} syntax
- Function calling with JSON schemas
- Tool choice strategies (auto, any, specific)
- Agent integration for consistent behavior
- KMS encryption support for enterprise scenarios

### 6. Guardrail - Content Safety and Compliance

```yaml
kind: Guardrail
metadata:
  name: string (required)
  description: string (optional)
spec:
  description: string (optional)
  tags: map[string]string (optional)
  
  # Content policy for harmful content
  contentPolicyConfig: (optional)
    filtersConfig:
      - type: string (required) # "SEXUAL", "VIOLENCE", "HATE", "INSULTS", "MISCONDUCT", "PROMPT_ATTACK"
        inputStrength: string (required) # "NONE", "LOW", "MEDIUM", "HIGH"
        outputStrength: string (required)
  
  # Sensitive information policy
  sensitiveInformationPolicyConfig: (optional)
    piiEntitiesConfig:
      - type: string (required) # "EMAIL", "PHONE", "SSN", etc.
        action: string (required) # "BLOCK", "ANONYMIZE"
  
  # Contextual grounding policy
  contextualGroundingPolicyConfig: (optional)
    filtersConfig:
      - type: string (required) # "GROUNDING", "RELEVANCE"
        threshold: float64 (required) # 0.0 to 1.0
  
  # Topic policy for allowed/denied topics
  topicPolicyConfig: (optional)
    topicsConfig:
      - name: string (required)
        definition: string (required)
        examples: []string (optional)
        type: string (required) # "DENY"
  
  # Word policy for profanity filtering
  wordPolicyConfig: (optional)
    wordsConfig: (optional)
      - text: string (required)
    managedWordListsConfig: (optional)
      - type: string (required) # "PROFANITY"
```

**Key Features:**
- Comprehensive content filtering capabilities
- PII detection and anonymization
- Contextual grounding validation
- Custom topic and word policies
- Integration with agents via guardrail references

### 7. OpenSearchServerless - Vector Collections for Knowledge Bases

```yaml
kind: OpenSearchServerless
metadata:
  name: string (required)
  description: string (optional)
spec:
  collectionName: string (required)
  description: string (optional)
  type: string (optional) # Default: "VECTORSEARCH"
  tags: map[string]string (optional)
  
  # Security policies
  encryptionPolicy: (optional)
    name: string (optional)
    description: string (optional)
    type: string (optional)
    kmsKeyId: string (optional)
  
  networkPolicy: (optional)
    name: string (optional)
    description: string (optional)
    type: string (optional)
    access: (optional)
      - sourceVPCEs: []string (optional)
        sourceType: string (optional)
  
  accessPolicy: (optional)
    name: string (optional)
    description: string (optional)
    type: string (optional)
    principals: []string (optional)
    permissions: []string (optional)
    autoConfigureForBedrock: bool (optional) # Simplified Bedrock permissions
  
  # Vector index configuration
  vectorIndex: (optional)
    name: string (required)
    fieldMapping:
      vectorField: string (required)
      textField: string (required)
      metadataField: string (required)
```

**Key Features:**
- Automatic security policy generation
- Bedrock-optimized access policies
- Vector index creation with proper field mapping
- Integration with KnowledgeBase resources

### 8. IAMRole - Custom IAM Roles (Optional)

```yaml
kind: IAMRole
metadata:
  name: string (required)
  description: string (optional)
spec:
  description: string (optional)
  tags: map[string]string (optional)
  
  # Assume role policy
  assumeRolePolicy: (required)
    version: string (required) # "2012-10-17"
    statement:
      - effect: string (required) # "Allow"
        principal: map[string]interface{} (required)
        action: string|[]string (required)
        condition: map[string]interface{} (optional)
  
  # Managed policies
  policies: (optional)
    - policyArn: string (required)
      policyName: {ref: policy-name} | "policy-name" # Reference to policy resource
  
  # Inline policies
  inlinePolicies: (optional)
    - name: string (required)
      policy:
        version: string (required)
        statement:
          - sid: string (optional)
            effect: string (required)
            action: string|[]string (required)
            resource: string|[]string (required)
            condition: map[string]interface{} (optional)
```

**Note:** IAM roles are automatically generated for agents and Lambda functions. Use custom IAMRole resources only for specific enterprise requirements.

## IAM Security and Best Practices

### Auto-Generated IAM Roles

Bedrock Forge automatically generates IAM roles with **least-privilege permissions** for maximum security:

**Agent Execution Roles:**
- **Bedrock permissions**: `bedrock:InvokeModel`, `bedrock:InvokeModelWithResponseStream`
- **Inference Profile permissions**: `bedrock:GetInferenceProfile`, `bedrock:ListInferenceProfiles`, `bedrock:UseInferenceProfile`  
- **Specific Lambda permissions**: Uses actual Lambda function ARNs instead of wildcards (e.g., `aws_lambda_function.text_processor.arn`)
- **Knowledge Base permissions**: `bedrock:Retrieve`, `bedrock:RetrieveAndGenerate` (when knowledge bases are used)
- **CloudWatch Logs permissions**: `logs:CreateLogGroup`, `logs:CreateLogStream`, `logs:PutLogEvents`

**Lambda Execution Roles:**
- **Basic execution permissions**: `AWSLambdaBasicExecutionRole` managed policy
- **Smart S3 permissions**: Automatically added when environment variables reference S3 resources
- **VPC permissions**: `AWSLambdaVPCAccessExecutionRole` when VPC configuration is specified

### Security Improvements

**Refined Lambda Permissions (New):**
```hcl
# BEFORE: Used wildcards (less secure)
"Resource": "arn:aws:lambda:*:*:function:*"

# AFTER: Uses specific Lambda ARNs (more secure)
"Resource": [
  "${aws_lambda_function.text_processor_lambda.arn}",
  "${aws_lambda_function.summary_generator_lambda.arn}"
]
```

**Smart S3 Permission Detection (New):**
```yaml
# When Lambda environment variables reference S3 buckets:
environment:
  S3_BUCKET: "${aws_s3_bucket.document_storage_bucket.bucket}"

# bedrock-forge automatically adds these permissions:
# Object-level permissions:
# - s3:GetObject, s3:PutObject, s3:DeleteObject on arn:aws:s3:::*/*
# Bucket-level permissions:  
# - s3:ListBucket, s3:GetBucketLocation on arn:aws:s3:::*
```

### IAM Role Customization Options

**1. Enterprise IAM Role Management:**
```yaml
# Use existing enterprise IAM role
kind: Agent
spec:
  iamRole:
    roleArn: "arn:aws:iam::123456789012:role/BedrockAgentExecutionRole"
```

**2. Cross-Account Access:**
```yaml
# Reference IAM role from another account
kind: Agent
spec:
  iamRole:
    roleArn: "arn:aws:iam::987654321098:role/CrossAccountBedrockRole"
```

**3. Custom IAM Role Resource:**
```yaml
# Define custom IAM role with specific permissions
kind: IAMRole
metadata:
  name: custom-agent-execution-role
spec:
  assumeRolePolicy:
    version: "2012-10-17"
    statement:
      - effect: Allow
        principal:
          Service: bedrock.amazonaws.com
        action: sts:AssumeRole
  policies:
    - policyArn: "arn:aws:iam::aws:policy/AmazonBedrockFullAccess"
  inlinePolicies:
    - name: CustomLambdaPermissions
      policy:
        version: "2012-10-17"
        statement:
          - effect: Allow
            action: lambda:InvokeFunction
            resource: 
              - "arn:aws:lambda:us-east-1:123456789012:function:specific-function"

# Reference the custom role
kind: Agent
spec:
  iamRole:
    roleName: {ref: custom-agent-execution-role}
```

**4. Additional Policies for Auto-Generated Roles:**
```yaml
# Add extra policies to auto-generated roles
kind: Agent
spec:
  iamRole:
    autoCreate: true
    additionalPolicies:
      - policyArn: "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess"
      - policyArn: "arn:aws:iam::aws:policy/AmazonDynamoDBReadOnlyAccess"
```

### When to Use Custom IAM Roles

**Use Auto-Generated Roles When:**
- Building new applications with standard permissions
- Want zero-configuration security setup
- Need least-privilege access automatically applied
- Using standard Bedrock + Lambda + S3 architecture

**Use Custom IAM Roles When:**
- Enterprise compliance requires specific IAM role patterns
- Cross-account access is needed
- Integration with existing IAM infrastructure
- Custom permissions beyond standard Bedrock + Lambda + S3
- Centralized IAM role management is required

### 10. AgentKnowledgeBaseAssociation - Link Agents to Knowledge Bases

```yaml
kind: AgentKnowledgeBaseAssociation
metadata:
  name: string (required)
  description: string (optional)
spec:
  # Agent reference (required)
  agentName: {ref: agent-name} | "agent-name" # Reference to Agent resource
  
  # Knowledge base reference (required)
  knowledgeBaseName: {ref: kb-name} | "kb-name" # Reference to KnowledgeBase resource
  
  # Optional configuration
  description: string (optional)
  state: string (optional) # "ENABLED" or "DISABLED"
```

**Key Features:**
- Links existing agents to knowledge bases
- Enables retrieval augmented generation (RAG)
- Supports multiple knowledge bases per agent
- Automatic dependency management

### 11. CustomResources - Include Your Own Terraform Files

```yaml
kind: CustomResources
metadata:
  name: string (required)
  description: string (optional)
spec:
  # Directory containing .tf files OR specific files (mutually exclusive)
  path: string (optional) # e.g., "./terraform/" or "../infrastructure/"
  files: []string (optional) # e.g., ["sns.tf", "eventbridge.tf"]
  
  # Variables to pass to your Terraform configuration
  variables: map[string]interface{} (optional)
  
  # Dependencies for proper ordering
  dependsOn: [{ref: resource-name} | "resource-name"] (optional)
  
  # Description of what these resources provide
  description: string (optional)
```

**Example Terraform Files:**
```hcl
# terraform/sns.tf
resource "aws_sns_topic" "agent_notifications" {
  name = var.sns_topic_name
  
  tags = {
    Environment = var.environment
    ManagedBy   = "bedrock-forge"
  }
}

output "sns_topic_arn" {
  value = aws_sns_topic.agent_notifications.arn
}
```

**Cross-Reference in Agents:**
```yaml
kind: Agent
metadata:
  name: notification-agent
spec:
  environment:
    SNS_TOPIC_ARN: "${aws_sns_topic.agent_notifications.arn}"
  dependsOn:
    - infrastructure
```

**Key Features:**
- Include any AWS resource using standard Terraform syntax
- Supports both directory paths and specific file lists
- Automatic path resolution from source directory
- Variable support with automatic merging and type conversion
- Cross-reference resources in agent configurations
- Generated variables.tf files for each CustomResource
- Proper dependency ordering with other resources
- Files are copied to the output directory for unified deployment

## GitHub Actions CI/CD Workflows

Bedrock Forge can be used as a GitHub Action in your CI/CD pipelines. There are two approaches:

### Approach 1: Direct Workflow (Recommended for Simple Projects)

**Purpose:** Direct deployment workflow using bedrock-forge GitHub Action

```yaml
# .github/workflows/deploy-bedrock.yml
name: Deploy Bedrock Agents

on:
  push:
    branches: [main]
    paths: ['**/*.yml', '**/*.yaml']

jobs:
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    environment: development
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOYMENT_ROLE }}
        aws-region: us-east-1
    
    - name: Generate Terraform
      uses: chandra447/bedrock-forge@main
      with:
        command: 'generate'
        output-dir: 'outputs_tf'
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"
        
    - name: Terraform Init
      run: |
        cd outputs_tf
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=project-name/dev/terraform.tfstate" \
          -backend-config="region=us-east-1"
          
    - name: Terraform Plan
      run: |
        cd outputs_tf
        terraform plan -out=tfplan
        
    - name: Terraform Apply
      run: |
        cd outputs_tf
        terraform apply tfplan
        
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    needs: deploy-dev
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOYMENT_ROLE }}
        aws-region: us-east-1
    
    - name: Generate Terraform
      uses: chandra447/bedrock-forge@main
      with:
        command: 'generate'
        output-dir: 'outputs_tf'
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"
        
    - name: Terraform Init
      run: |
        cd outputs_tf
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="key=project-name/prod/terraform.tfstate" \
          -backend-config="region=us-east-1"
          
    - name: Terraform Plan
      run: |
        cd outputs_tf
        terraform plan -out=tfplan
        
    - name: Terraform Apply
      run: |
        cd outputs_tf
        terraform apply tfplan
```

**Optional Validation Workflow for Pull Requests:**

```yaml
# .github/workflows/validate-bedrock.yml
name: Validate Bedrock Configuration

on:
  pull_request:
    branches: [main]
    paths: ['**/*.yml', '**/*.yaml']

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_DEPLOYMENT_ROLE }}
        aws-region: us-east-1
    
    - name: Validate YAML
      uses: chandra447/bedrock-forge@main
      with:
        command: 'validate'
        
    - name: Generate Terraform (for validation)
      uses: chandra447/bedrock-forge@main
      with:
        command: 'generate'
        output-dir: 'outputs_tf'
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"
        
    - name: Terraform Format Check
      run: |
        cd outputs_tf
        terraform fmt -check
        
    - name: Terraform Validate
      run: |
        cd outputs_tf
        terraform init -backend=false
        terraform validate
```

### Approach 2: Reusable Workflows (For Enterprise/Complex Projects)

**Purpose:** Centralized reusable workflows for multiple projects

```yaml
# .github/workflows/deploy-bedrock.yml
name: Deploy Bedrock Agents

on:
  push:
    branches: [main]
    paths: ['**/*.yml', '**/*.yaml']

jobs:
  deploy-dev:
    uses: your-org/bedrock-forge/.github/workflows/bedrock-forge-deploy.yml@main
    with:
      environment: dev
      aws_role: ${{ secrets.AWS_DEPLOYMENT_ROLE }}
      tf_state_bucket: ${{ secrets.TERRAFORM_STATE_BUCKET }}
    secrets: inherit
```

**Note:** This approach requires you to create reusable workflow files in a central repository.

### GitHub Action Inputs

The `chandra447/bedrock-forge` action supports these inputs:

- **command** (required): Command to run (`generate`, `validate`, `scan`)
- **output-dir** (optional): Output directory for generated files (default: `terraform`)
- **config-path** (optional): Path to configuration files (default: `.`)
- **validation-config** (optional): Path to validation configuration file
- **debug** (optional): Enable debug mode (default: `false`)

### Required Secrets

```
AWS_DEPLOYMENT_ROLE=arn:aws:iam::123456789012:role/GitHubActionsDeploymentRole
TERRAFORM_STATE_BUCKET=your-terraform-state-bucket
```

### Environment Configuration

Set up GitHub Environments (development, production) with:
- Protection rules requiring manual approval for production
- Environment-specific secrets if needed
- Deployment branch restrictions

## Common Patterns and Examples

### 1. Reference Syntax Examples

```yaml
# Using object syntax (recommended)
kind: Agent
metadata:
  name: modern-agent
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are a helpful assistant"
  guardrail:
    name: {ref: content-safety}  # Object syntax
  actionGroups:
    - name: tools
      actionGroupExecutor:
        lambda: {ref: utility-functions}  # Object syntax
  promptOverrides:
    - promptType: "PRE_PROCESSING"
      prompt: {ref: preprocessing-prompt}  # Object syntax

# Using string syntax (legacy)
kind: Agent
metadata:
  name: legacy-agent
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are a helpful assistant"
  guardrail:
    name: "content-safety"  # String syntax
  actionGroups:
    - name: tools
      actionGroupExecutor:
        lambda: "utility-functions"  # String syntax
  promptOverrides:
    - promptType: "PRE_PROCESSING"
      prompt: "preprocessing-prompt"  # String syntax

# Mixed syntax (supported but not recommended)
kind: ActionGroup
metadata:
  name: mixed-references
spec:
  agentId: {ref: target-agent}     # Object syntax
  actionGroupExecutor:
    lambda: "helper-function"      # String syntax
```

### 2. Complete Multi-Lambda Agent with S3 Integration

```yaml
# s3-infrastructure.yml
kind: CustomResources
metadata:
  name: document-storage-bucket
spec:
  files: ["s3.tf"]
  variables:
    bucket_name: "document-processing-storage"
    environment: "production"

# lambda-text-processor.yml
kind: Lambda
metadata:
  name: text-processor-lambda
  description: "Lambda function for processing text documents"
spec:
  runtime: python3.11
  handler: text_processor.lambda_handler
  code:
    source: "./lambda-functions/text-processor/"
  environment:
    LOG_LEVEL: "INFO"
    S3_BUCKET: "${aws_s3_bucket.document_storage_bucket.bucket}"
    # bedrock-forge automatically detects S3 reference and adds IAM permissions
  timeout: 60
  memorySize: 512
  architectures: ["x86_64"]
  tracingConfig:
    mode: "Active"
  publish: true
  tags:
    Function: "text-processing"
    Environment: "production"

# lambda-summary-generator.yml  
kind: Lambda
metadata:
  name: summary-generator-lambda
  description: "Lambda function for generating summaries from processed text"
spec:
  runtime: python3.11
  handler: summary_generator.lambda_handler
  code:
    source: "./lambda-functions/summary-generator/"
  environment:
    LOG_LEVEL: "INFO"
    S3_BUCKET: "${aws_s3_bucket.document_storage_bucket.bucket}"
    # bedrock-forge automatically detects S3 reference and adds IAM permissions
  timeout: 30
  memorySize: 256
  architectures: ["arm64"]
  tracingConfig:
    mode: "Active"
  publish: true
  tags:
    Function: "summary-generation"
    Environment: "production"

# agent-document-assistant.yml
kind: Agent
metadata:
  name: document-assistant-agent
  description: "AI assistant for document processing and summarization"
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  
  # Uses auto-generated IAM role with refined Lambda permissions
  # (no iamRole specified = auto-generate with specific Lambda ARNs)
  
  instruction: |
    You are a document processing assistant. You can:
    1. Process text documents from S3 buckets
    2. Generate summaries of processed documents
    3. Answer questions about document content
    
    When users ask you to process documents, use the appropriate tools based on their needs.
    
  actionGroups:
    - name: "text-processing-actions"
      description: "Actions for processing text documents"
      actionGroupExecutor:
        lambda: {ref: text-processor-lambda}
      functionSchema:
        functions:
          - name: "process_text"
            description: "Process text document from S3 bucket"
            parameters:
              s3_bucket:
                description: "S3 bucket containing the document"
                required: true
                type: "string"
              s3_key:
                description: "S3 key of the document"
                required: true
                type: "string"
              processing_type:
                description: "Type of processing to perform (extract, analyze, clean)"
                required: true
                type: "string"
          
    - name: "summary-generation-actions"
      description: "Actions for generating document summaries"
      actionGroupExecutor:
        lambda: {ref: summary-generator-lambda}
      functionSchema:
        functions:
          - name: "generate_summary"
            description: "Generate document summary from text"
            parameters:
              text:
                description: "Text to summarize"
                required: true
                type: "string"
              summary_type:
                description: "Type of summary to generate (brief, detailed, bullet_points)"
                required: true
                type: "string"
              max_length:
                description: "Maximum length of summary"
                required: false
                type: "string"
          
  tags:
    Application: "document-processing"
    Environment: "production"
    Project: "document-processing"
    Owner: "team@company.com"
    AgentType: "document-assistant"
```

**Generated IAM Permissions (Auto-Generated):**
```hcl
# Agent execution role with refined Lambda permissions
resource "aws_iam_role_policy" "document_assistant_agent_execution_role_inline_policy" {
  policy = jsonencode({
    Statement = [
      {
        Effect = "Allow"
        Action = ["lambda:InvokeFunction"]
        Resource = [
          # Uses specific Lambda ARNs instead of wildcards
          aws_lambda_function.text_processor_lambda.arn,
          aws_lambda_function.summary_generator_lambda.arn
        ]
      }
    ]
  })
}

# Lambda execution roles with automatic S3 permissions
resource "aws_iam_role_policy" "text_processor_lambda_execution_role_s3_policy" {
  policy = jsonencode({
    Statement = [
      {
        Effect = "Allow"
        Action = ["s3:GetObject", "s3:PutObject", "s3:DeleteObject"]
        Resource = "arn:aws:s3:::*/*"
      },
      {
        Effect = "Allow"
        Action = ["s3:ListBucket", "s3:GetBucketLocation"]
        Resource = "arn:aws:s3:::*"
      }
    ]
  })
}
```

### 3. Agent with Custom IAM Role

```yaml
# custom-iam-role.yml
kind: IAMRole
metadata:
  name: enterprise-agent-execution-role
spec:
  assumeRolePolicy:
    version: "2012-10-17"
    statement:
      - effect: Allow
        principal:
          Service: bedrock.amazonaws.com
        action: sts:AssumeRole
  policies:
    - policyArn: "arn:aws:iam::aws:policy/AmazonBedrockFullAccess"
  inlinePolicies:
    - name: CustomLambdaPermissions
      policy:
        version: "2012-10-17"
        statement:
          - effect: Allow
            action: lambda:InvokeFunction
            resource: 
              - "arn:aws:lambda:us-east-1:123456789012:function:approved-function-1"
              - "arn:aws:lambda:us-east-1:123456789012:function:approved-function-2"

# agent-with-custom-iam.yml
kind: Agent
metadata:
  name: enterprise-agent
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are an enterprise assistant with custom IAM permissions"
  
  # Option 1: Reference custom IAM role resource
  iamRole:
    roleName: {ref: enterprise-agent-execution-role}
  
  # Option 2: Use existing IAM role ARN
  # iamRole:
  #   roleArn: "arn:aws:iam::123456789012:role/ExistingEnterpriseRole"
  
  # Option 3: Auto-generate with additional policies
  # iamRole:
  #   autoCreate: true
  #   additionalPolicies:
  #     - policyArn: "arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess"
  
  actionGroups:
    - name: enterprise-tools
      actionGroupExecutor:
        lambda: {ref: enterprise-lambda}
      functionSchema:
        functions:
          - name: enterprise_action
            description: "Enterprise-specific action"
            parameters:
              action_type:
                description: "Type of enterprise action"
                required: true
                type: string
```

### 4. Basic Agent with Lambda Action Group

```yaml
# lambda.yml
kind: Lambda
metadata:
  name: order-lookup
spec:
  runtime: python3.9
  handler: app.handler
  code:
    source: directory

# agent.yml
kind: Agent
metadata:
  name: customer-support
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are a helpful customer support agent..."
  actionGroups:
    - name: order-management
      actionGroupExecutor:
        lambda: {ref: order-lookup}
      functionSchema:
        functions:
          - name: lookup_order
            description: "Look up customer order by ID"
            parameters:
              order_id:
                description: "The order ID to look up"
                required: true
                type: string
```

### 5. Knowledge Base with Agent Association

```yaml
# opensearch.yml
kind: OpenSearchServerless
metadata:
  name: knowledge-store
spec:
  collectionName: "company-knowledge"
  vectorIndex:
    name: "docs-index"
    fieldMapping:
      vectorField: "vector"
      textField: "text"
      metadataField: "metadata"

# knowledge-base.yml
kind: KnowledgeBase
metadata:
  name: company-docs
spec:
  knowledgeBaseConfiguration:
    type: VECTOR
    vectorKnowledgeBaseConfiguration:
      embeddingModelArn: "arn:aws:bedrock:us-east-1::foundation-model/amazon.titan-embed-text-v1"
  storageConfiguration:
    type: OPENSEARCH_SERVERLESS
    openSearchServerless:
      collectionName: {ref: knowledge-store}
      vectorIndexName: "docs-index"
      fieldMapping:
        vectorField: "vector"
        textField: "text"
        metadataField: "metadata"
  dataSources:
    - name: company-documents
      type: S3
      s3Configuration:
        bucketArn: "arn:aws:s3:::company-docs-bucket"

# agent.yml
kind: Agent
metadata:
  name: knowledge-agent
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are an assistant with access to company knowledge..."

# association.yml
kind: AgentKnowledgeBaseAssociation
metadata:
  name: agent-kb-link
spec:
  agentName: {ref: knowledge-agent}
  knowledgeBaseName: {ref: company-docs}
  description: "Link agent to company knowledge base"
  state: "ENABLED"
```

### 6. Knowledge Base with Custom Infrastructure

```yaml
# infrastructure.yml
kind: CustomResources
metadata:
  name: vector-infrastructure
spec:
  files: ["s3.tf", "opensearch.tf"]
  variables:
    bucket_name: "knowledge-base-docs"

# knowledge-base.yml
kind: KnowledgeBase
metadata:
  name: company-docs
spec:
  knowledgeBaseConfiguration:
    type: VECTOR
    vectorKnowledgeBaseConfiguration:
      embeddingModelArn: "arn:aws:bedrock:us-east-1::foundation-model/amazon.titan-embed-text-v1"
  storageConfiguration:
    type: OPENSEARCH_SERVERLESS
    openSearchServerless:
      collectionName: "${aws_opensearchserverless_collection.kb_collection.name}"
      vectorIndexName: "knowledge-base-index"
      fieldMapping:
        vectorField: "vector"
        textField: "text"
        metadataField: "metadata"
  dataSources:
    - name: company-documents
      type: S3
      s3Configuration:
        bucketArn: "${aws_s3_bucket.docs.arn}"
  dependsOn:
    - {ref: vector-infrastructure}
```

### 7. Prompt with Tool Calling

```yaml
kind: Prompt
metadata:
  name: function-calling-prompt
spec:
  variants:
    - name: default
      modelId: "anthropic.claude-3-sonnet-20240229-v1:0"
      templateType: CHAT
      templateConfiguration:
        chat:
          system:
            - text: "You are a helpful assistant that can call functions to help users."
          inputVariables:
            - name: query
          toolConfiguration:
            tools:
              - toolSpec:
                  name: get_weather
                  description: "Get current weather for a location"
                  inputSchema:
                    json:
                      type: object
                      properties:
                        location:
                          type: string
                          description: "City name"
                      required: [location]
            toolChoice:
              auto: {}
```

### 8. Enterprise Agent with Guardrails

```yaml
# guardrail.yml
kind: Guardrail
metadata:
  name: enterprise-safety
spec:
  contentPolicyConfig:
    filtersConfig:
      - type: SEXUAL
        inputStrength: HIGH
        outputStrength: HIGH
      - type: VIOLENCE
        inputStrength: HIGH
        outputStrength: HIGH
  sensitiveInformationPolicyConfig:
    piiEntitiesConfig:
      - type: EMAIL
        action: ANONYMIZE
      - type: PHONE
        action: BLOCK

# agent.yml  
kind: Agent
metadata:
  name: enterprise-agent
spec:
  foundationModel: "anthropic.claude-3-sonnet-20240229-v1:0"
  instruction: "You are an enterprise customer service agent..."
  guardrail:
    name: {ref: enterprise-safety}
  tags:
    Environment: production
    Team: customer-service
    Compliance: required
```

## Dependency Management and Cross-References

**Resource Creation Order:**
1. IAMRole → CustomResources → Guardrail → Prompt → Lambda
2. OpenSearchServerless → KnowledgeBase → ActionGroup → Agent
3. AgentKnowledgeBaseAssociation (after both Agent and KnowledgeBase)

**Cross-Reference Patterns:**
- Lambda functions: `{ref: lambda-name}` or `"lambda-name"` in ActionGroups
- Guardrails: `{ref: guardrail-name}` or `"guardrail-name"` in Agents
- Prompts: `{ref: prompt-name}` or `"prompt-name"` in Agent promptOverrides
- Custom resources: Use Terraform syntax `${resource.name.output}`
- Agent references: `{ref: agent-name}` or `"agent-name"` for cross-references
- Knowledge base references: `{ref: kb-name}` or `"kb-name"` in associations

**Dependencies:**
```yaml
spec:
  dependsOn:
    - {ref: lambda-function-name}  # Lambda resource reference
    - {ref: infrastructure}        # CustomResources reference
    - "safety-guardrail"           # Guardrail resource (string syntax)
```

## Recent Improvements

### Enhanced IAM Security and Customization

**Refined Lambda Permissions:**
- **Security Enhancement**: Agent execution roles now use specific Lambda function ARNs instead of wildcards
- **Improved**: `"Resource": "arn:aws:lambda:*:*:function:*"` → `"Resource": ["${aws_lambda_function.text_processor.arn}"]`
- **Benefit**: Follows principle of least privilege, reducing attack surface

**Flexible IAM Role Management:**
- **New Feature**: Users can now opt out of auto-generated IAM roles
- **Options Added**: Use existing IAM role ARNs, reference custom IAMRole resources, or extend auto-generated roles
- **Enterprise Support**: Cross-account access, compliance-specific role patterns, centralized IAM management
- **Backward Compatible**: Existing configurations continue to work without changes

**Smart S3 Permission Detection:**
- **Auto-Detection**: Automatically adds S3 permissions when Lambda environment variables reference S3 buckets
- **Comprehensive**: Includes both object-level (`s3:GetObject`, `s3:PutObject`, `s3:DeleteObject`) and bucket-level (`s3:ListBucket`, `s3:GetBucketLocation`) permissions
- **Zero-Configuration**: No manual IAM policy management required for S3 integration

### Advanced Lambda Integration

**Enhanced Lambda Configuration:**
- **Tracing Support**: Full AWS X-Ray tracing configuration with block syntax
- **Architecture Options**: Support for both x86_64 and ARM64 architectures
- **Publishing**: Automatic Lambda versioning with `publish: true`
- **Smart Permissions**: Automatic detection of required permissions based on configuration

**Improved Resource Generation:**
- **Native Resources**: Uses native AWS Terraform resources instead of external modules
- **Proper Syntax**: Fixed block vs object syntax issues (e.g., `tracing_config { }` instead of `tracing_config = { }`)
- **Better References**: Proper Terraform resource references without double-escaping

### Enhanced CustomResources Support
- **Fixed "invalid custom resources spec format" error**: Resolved issue where CustomResources couldn't be properly parsed due to missing registry conversion
- **Improved path handling**: CustomResources now properly resolves relative paths from the source directory
- **Automatic output directory creation**: The CLI now creates the output directory automatically
- **Better error messages**: More descriptive error messages for missing files and directories

### CLI Improvements
- **New default output directory**: Changed from `./terraform` to `outputs_tf` for better user experience
- **Enhanced help text**: Added detailed argument descriptions and examples
- **Zero-setup generation**: Users can immediately inspect generated .tf files without manual setup
- **Improved file copying**: CustomResources files are now copied with proper source directory context

### Tag Validation Fixes
- **Fixed knowledge base chunking configuration**: Resolved inconsistent list element types causing panics
- **Improved null handling**: Better handling of optional fields in chunking configurations
- **Enhanced S3 configuration**: Fixed missing inclusion/exclusion prefixes causing validation errors
- **Consistent field structure**: All optional fields now properly default to null for consistent HCL generation

### Deprecated Features Removed
- **CustomModule support removed**: Simplified codebase by removing deprecated CustomModule functionality
- **Focus on CustomResources**: All custom Terraform integration now uses the more flexible CustomResources approach

## Best Practices

### 1. Resource Organization
- Use descriptive names that indicate purpose
- Group related resources in the same file
- Use consistent naming conventions across environments

### 2. Security
- Let bedrock-forge auto-generate IAM roles (includes all necessary permissions)
- Use guardrails for content safety in production
- Enable KMS encryption for sensitive prompts

### 3. Infrastructure Integration
- Use CustomResources for AWS resources not directly supported
- Store supporting infrastructure (.tf files) in organized directories
- Cross-reference custom resources in agent environment variables

### 4. CI/CD
- Use validation workflow for all pull requests
- Require manual approval for production deployments
- Store Terraform artifacts in S3 for auditability

### 5. Development Workflow
- Start with basic agents and iteratively add complexity
- Use inline action groups for simpler deployments
- Test locally with `bedrock-forge validate` and `bedrock-forge generate`

This comprehensive reference covers all bedrock-forge capabilities based on the actual implementation, providing accurate field specifications, validation rules, and real-world usage patterns for rapid AWS Bedrock development.